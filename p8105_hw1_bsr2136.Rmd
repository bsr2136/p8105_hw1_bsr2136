---
title: "p8105_hw1_bsr2136"
author: Barik Rajpal
date: September 19, 2019
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Problem 1 - Variable Types
### Problem 1.1 - Data Frame, Vectors, and Means

```{r Problem 1.1}

vec_df <- tibble(
normal_sample_vec = rnorm(8),
logic_vec = normal_sample_vec > 0,
char_vec = c('a','b','c','d','e','f','g','h'),
factor_vec = as.factor(c('H','M','L','H','M','L','H','M'))
)

mean(pull(vec_df,normal_sample_vec))
mean(pull(vec_df,logic_vec))
mean(pull(vec_df,char_vec))
mean(pull(vec_df,factor_vec))
```

I can take the mean of the numeric and logical vectors, and the result returned is a numeric. Trying to take the mean of the character and factor vectors returns NA, and gives me the warning that the argument is not numeric and logical.

### Problem 1.2 - converting logic,char, and factor vectors using as.numeric

```{r Problem 1.2, results=FALSE}
as.numeric(pull(vec_df,logic_vec))
as.numeric(pull(vec_df,char_vec))
as.numeric(pull(vec_df,factor_vec))
```

The logical and factor vectors were able to be converted to numeric, with the logical vector taking the values 0 and 1, and the factor vector taking the values 1,2, and 3 (the number of levels). The character vector returned a numeric vector of all NAs and returned the warning "NAs introduced by coercion". This clearly explains what the mean of the logic vector was, and why the character vector mean was NA. The factor vector changed significantly when converted to numeric, which explains why the mean returned NA originally.

### Problem 1.3 - Convert and Multiply

```{r Problem 1.3}
as.numeric(pull(vec_df,logic_vec)) * pull(vec_df,normal_sample_vec)
as.factor(pull(vec_df,logic_vec)) * pull(vec_df,normal_sample_vec)
as.numeric(as.factor(pull(vec_df,logic_vec))) * pull(vec_df,normal_sample_vec)
```


## Problem 2 - Inline R Coding and plotting

### Problem 2.1 - Tibble with inline code

``` {r Problem 2.1}
plot_df <- tibble(
  x = rnorm(500),
  y = rnorm(500),
  logxy = x + y > 1,
  numxy = as.numeric(logxy),
  facxy = as.factor(logxy)
)

# The number of rows in the dataset are
nrow(plot_df)
# The number of columns in the dataset are
ncol(plot_df)
# The mean of x is
mean(pull(plot_df,x))
# The median of x is
median(pull(plot_df,x))
# The standard deviation of x is
sd(pull(plot_df,x))
# The proportion of cases where x + y > 1 is
sum(pull(plot_df,logxy))/500
```


### Problem 2.2 Making Scatterplots

``` {r Problem 2.2} 

sc_plot1 <- plot_df %>%
  ggplot(aes(y,x,color = logxy)) + geom_point()
#The colors shown are red and blue and they represent the values FALSE and TRUE, respectively.

sc_plot2 <- plot_df %>%
  ggplot(aes(y,x,color = numxy)) + geom_point()
# The legend for the color scale in the above plot is continuous, from dark blue to light blue (0 to 1), but still displays in the points as binary, because the values are either 0 or 1

sc_plot3 <- plot_df %>%
  ggplot(aes(y,x,color = facxy)) + geom_point()
# The colors and legend in this plot appear identical to plot1 with the logical vector being used as color

ggsave('xy_scatterplot.png',plot = sc_plot1)
```
